options {
  LOOKAHEAD = 2;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;
  STATIC = false;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = false;
  IGNORE_CASE = false;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER = true;
  SANITY_CHECK = true;
}

PARSER_BEGIN(TAPAALQueryParser)

package dk.aau.cs.TCTL.Parsing;

import java.io.StringReader;
import java.util.ArrayList;

import dk.aau.cs.TCTL.TCTLAFNode;
import dk.aau.cs.TCTL.TCTLAGNode;
import dk.aau.cs.TCTL.TCTLAbstractProperty;
import dk.aau.cs.TCTL.TCTLAbstractStateProperty;
import dk.aau.cs.TCTL.TCTLAndListNode;
import dk.aau.cs.TCTL.TCTLAtomicPropositionNode;
import dk.aau.cs.TCTL.TCTLEFNode;
import dk.aau.cs.TCTL.TCTLEGNode;
import dk.aau.cs.TCTL.TCTLFalseNode;
import dk.aau.cs.TCTL.TCTLNotNode;
import dk.aau.cs.TCTL.TCTLOrListNode;
import dk.aau.cs.TCTL.TCTLTrueNode;
import dk.aau.cs.TCTL.TCTLDeadlockNode;

public class TAPAALQueryParser {

	private static final String ERROR_PARSING_QUERY_MESSAGE = "TAPAAL countered an error trying to parse the query";

	public static TCTLAbstractProperty parse(String query) throws ParseException {
		TAPAALQueryParser parser = new TAPAALQueryParser(new StringReader(query));
		return parser.AbstractProperty();
	}
}

PARSER_END(TAPAALQueryParser)

TOKEN :
{
	<TRUE: "true" | "TRUE">
	|
	<FALSE: "false" | "FALSE">
	|
	<DEADLOCK: "deadlock" | "DEADLOCK">
}

TOKEN :
{
	<EF: "EF" | "E<>">
	|
	<EG: "EG" | "E[]">
	|
	<AF: "AF" | "A<>">
	|
	<AG: "AG" | "A[]">
}

TOKEN :
{
	<OR: "or" | "||">
	|
	<AND: "and" | "&&">
	|
	<NOT: "not" | "!">
}

TOKEN :
{
	< NUM: ( ["0"-"9"] )+ >
	|
	<IDENT: ["a"-"z","A"-"Z","_"] ( ["a"-"z","A"-"Z","_","0"-"9"] )* > 
}

TOKEN : 
{
	<OP: "<" | "<=" | ">" | "=" | "==" | ">=" | ">" >
}

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

/** Root production. */
TCTLAbstractProperty AbstractProperty() :
{
	TCTLAbstractStateProperty child = null; 
}
{
	( 
		<EF> child = OrExpr() {return new TCTLEFNode(child); } 
		| <EG> child = OrExpr() {return new TCTLEGNode(child); } 
		| <AF> child = OrExpr() {return new TCTLAFNode(child); } 
		| <AG> child = OrExpr() {return new TCTLAGNode(child); } 
	) 
}

TCTLAbstractStateProperty OrExpr() : 
{
	TCTLAbstractStateProperty currentChild; 
	ArrayList<TCTLAbstractStateProperty> disjunctions = new ArrayList<TCTLAbstractStateProperty>();
}
{
	currentChild = AndExpr()
	{ disjunctions.add(currentChild); }
	( 
		<OR> currentChild = AndExpr()
		{ disjunctions.add(currentChild); }
	)*
	{ return disjunctions.size() == 1 ? currentChild : new TCTLOrListNode(disjunctions); }
}

TCTLAbstractStateProperty AndExpr() :
{
	TCTLAbstractStateProperty currentChild; 
	ArrayList<TCTLAbstractStateProperty> conjunctions = new ArrayList<TCTLAbstractStateProperty>();
}
{
	currentChild = NotExpr()
	{ conjunctions.add(currentChild); }
	(
		<AND> currentChild = NotExpr() 
		{ conjunctions.add(currentChild); }
	)*
	{ return conjunctions.size() == 1 ? currentChild : new TCTLAndListNode(conjunctions); }
}

TCTLAbstractStateProperty NotExpr() :
{
	TCTLAbstractStateProperty child; 
}
{
	<NOT> "(" child = OrExpr() ")" { return new TCTLNotNode(child); }
	| child = Factor() { return child; }
}

TCTLAbstractStateProperty Factor() :
{
	TCTLAbstractStateProperty thisProp; 
}
{
	(
		<TRUE> {thisProp = new TCTLTrueNode(); }
		| <FALSE> {thisProp = new TCTLFalseNode(); }
		| <DEADLOCK> {thisProp = new TCTLDeadlockNode(); }
		| thisProp = AtomicProposition() 
		| "(" thisProp = OrExpr() ")"
	)
	{ return thisProp; }
}

TCTLAbstractStateProperty AtomicProposition() :
{
	Token template = null;
	Token place;
	Token op;
	Token num;
}
{
	( 
		[ template = <IDENT>  "." ]  place = <IDENT> op = <OP> num = <NUM> 
	)
	{ 	String templateString = template == null ? "" : template.image;
		String placeString = place.image;
		String opString = op.image.equals("==") ? "=" : op.image; 
		int n = Integer.parseInt(num.image);
		
		return new TCTLAtomicPropositionNode(templateString, placeString, opString, n);
	}
}