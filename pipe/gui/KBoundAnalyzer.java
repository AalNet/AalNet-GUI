package pipe.gui;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintStream;

import javax.swing.JOptionPane;

import pipe.dataLayer.DataLayer;
import dk.aau.cs.Messenger;
import dk.aau.cs.TA.NTA;
import dk.aau.cs.TAPN.ModelTransformer;
import dk.aau.cs.TAPN.TAPNToNTASymmetryTransformer;
import dk.aau.cs.TAPN.colorTranslations.ColoredDegree2BroadcastTransformer;
import dk.aau.cs.petrinet.TimedArcPetriNet;
import dk.aau.cs.translations.PipeToNTATransformer;

public class KBoundAnalyzer 
{
	protected DataLayer appModel;
	protected int k;
	private boolean notBounded = true;
	
	private boolean error=true;
	private boolean readingPropertyOneResult = false;
	
	private ModelTransformer<DataLayer, NTA> pipeToNtaTransformer;
	private Messenger messenger;
	
	
	public boolean isBounded() {
		return !notBounded;
	}
	
	public KBoundAnalyzer(DataLayer appModel, int k, Messenger messenger)
	{
		this.k = k;
		this.appModel = appModel;
		this.pipeToNtaTransformer = new PipeToNTATransformer(getReductionStrategy());
	}
	
	public void analyze()
	{
		NTA nta;
		try {
			nta = pipeToNtaTransformer.transformModel(appModel);
		} catch (Exception e) {
			messenger.displayErrorMessage("Something went wrong while preparing the model.");
			return;
		}
				
//			
//		try
//		{
//			notBounded = isNetBounded(a.bufferedReaderStderr, a.bufferedReaderStdout);
//		}
//		catch(Exception e)
//		{
//			System.err.println("There was an error verifying the model.");
//			return;
//		}
		
//		showResult(a);	
	}

	protected ModelTransformer<TimedArcPetriNet, NTA> getReductionStrategy() {
		if(!appModel.isUsingColors()){
			return new TAPNToNTASymmetryTransformer(k+1);
		}else{
			return new ColoredDegree2BroadcastTransformer(k+1, true);
		}
	}

	protected void showResult(RunVerificationBase a) {
		String resultmessage = "";
		
		String answerNetIsBounded = getAnswerBoundedString();
		String answerNetIsNotBounded = getAnswerNotBoundedString();
		
		
		//Display Answer
		resultmessage = notBounded ? answerNetIsNotBounded : answerNetIsBounded; 
		// TODO: MJ -- fix
		// resultmessage+= "\nAnalysis time is estimated to: " + (a.verificationtime/1000.0) + "s";
		
		JOptionPane.showMessageDialog(CreateGui.getApp(),
				resultmessage,
				"Boundness Analyses Result",
				JOptionPane.INFORMATION_MESSAGE);
	}
	
	protected boolean isNetBounded(BufferedReader bufferedReaderStderr, BufferedReader bufferedReaderStdout) throws Exception
	{
		String line=null;
		
		try {
			while ( (line = bufferedReaderStdout.readLine()) != null){	
				parseLine(line);
			}
		} catch (IOException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
			error=true;
		}
		
		if (error){
			throw new Exception("error");
		}
		
		return notBounded;
	}

	protected void parseLine(String line) {
		if(line.contains("property 1"))
			readingPropertyOneResult = true;
		
		if (readingPropertyOneResult && line.contains("Property is satisfied")) {
			notBounded = true;
			error=false;
			readingPropertyOneResult = false;
		}else if (readingPropertyOneResult && line.contains("Property is NOT satisfied.")){
			notBounded=false;
			error=false;
			readingPropertyOneResult = false;
		}
	}

	protected void printQuery(PrintStream stream) {
		String inputQuery = "A[] P_capacity >= 1";
		stream.println("// Autogenerated by the TAPAAL (www.tapaal.net)");
		stream.println("");

		stream.println("/*");
		stream.println(" " + inputQuery + " " );
		stream.println("*/");
		
		if(!appModel.isUsingColors()){
			//stream.println("A[]((sum(i:pid_t) P(i).P_capacity)>= 1) and (Control.finish == 1)");
			stream.println("E<>((sum(i:pid_t) Token(i).P_capacity)== 0) and (Control.finish == 1)");
		}else{
			stream.println("E<>((sum(i:pid_t) Token(i).P_capacity) == 0) and (Control.P_lock == 1) and lock == 0");
		}
	}

	protected String getAnswerNotBoundedString() {
		String answerNetIsNotBounded =
			"The net with the speficied extra number of tokens is either unbounded or\n" +
			"more extra tokens have to be added in order to achieve an exact analysis.\n\n" +
			"This means that the analysis using the currently selected number \n" +
			"of extra tokens provides only an underapproximation of the net behaviour.\n" +
			"If you think that the net is bounded, try to add more extra tokens in order\n" +
			"to achieve exact verification analysis.\n";
		return answerNetIsNotBounded;
	}

	protected String getAnswerBoundedString() {
		String answerNetIsBounded =
		//	"The net is "+ k +" bounded.\n\n" + 
			"The net with the specified extra number of tokens is bounded.\n\n" +
			"This means that the analysis using the currently selected number\n" +
			"of extra tokens will be exact and always give the correct answer.\n";
		return answerNetIsBounded;
	}
}
